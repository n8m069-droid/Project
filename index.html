<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="3D Analog Clock floating in a grid environment">
    <meta name="author" content="3D Clock App">
    <title>3D Analog Clock in Grid</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0e1a;
            font-family: 'Arial', sans-serif;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #4da6ff;
            background: rgba(10, 14, 26, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #4da6ff;
            font-size: 12px;
            z-index: 10;
        }

        #controls h3 {
            margin-bottom: 10px;
            color: #66b3ff;
        }

        #controls p {
            margin: 5px 0;
            line-height: 1.5;
        }

        @media (max-width: 768px) {
            #controls {
                font-size: 11px;
                padding: 10px;
                top: 10px;
                left: 10px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>3D Clock Controls</h3>
        <p>üñ±Ô∏è Drag to rotate view</p>
        <p>üîÑ Auto-rotating grid</p>
        <p>‚è∞ Real-time clock</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height, centerX, centerY;
        let mouseX = 0, mouseY = 0;
        let isDragging = false;
        let rotationX = -0.3;
        let rotationY = 0.5;
        let autoRotate = true;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
        }

        resize();
        window.addEventListener('resize', resize);

        // Mouse controls
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            autoRotate = false;
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                rotationY += e.movementX * 0.005;
                rotationX += e.movementY * 0.005;
                rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
            }
        });

        // Touch controls
        let lastTouchX = 0, lastTouchY = 0;
        canvas.addEventListener('touchstart', (e) => {
            isDragging = true;
            autoRotate = false;
            lastTouchX = e.touches[0].clientX;
            lastTouchY = e.touches[0].clientY;
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });

        canvas.addEventListener('touchmove', (e) => {
            if (isDragging) {
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                rotationY += (touchX - lastTouchX) * 0.005;
                rotationX += (touchY - lastTouchY) * 0.005;
                rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
                lastTouchX = touchX;
                lastTouchY = touchY;
                e.preventDefault();
            }
        }, { passive: false });

        // 3D projection
        function project(x, y, z) {
            const fov = 600;
            const scale = fov / (fov + z);
            return {
                x: centerX + x * scale,
                y: centerY + y * scale,
                scale: scale
            };
        }

        // Rotate point in 3D space
        function rotate3D(x, y, z, rx, ry) {
            // Rotate around Y axis
            let cosY = Math.cos(ry);
            let sinY = Math.sin(ry);
            let tempX = x * cosY - z * sinY;
            let tempZ = x * sinY + z * cosY;
            x = tempX;
            z = tempZ;

            // Rotate around X axis
            let cosX = Math.cos(rx);
            let sinX = Math.sin(rx);
            let tempY = y * cosX - z * sinX;
            tempZ = y * sinX + z * cosX;
            y = tempY;
            z = tempZ;

            return { x, y, z };
        }

        // Draw 3D grid
        function drawGrid() {
            const gridSize = 12;
            const spacing = 80;
            const offset = (gridSize - 1) * spacing / 2;

            ctx.strokeStyle = '#1a4d7a';
            ctx.lineWidth = 1;

            // Draw grid lines
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    // Horizontal lines (floor)
                    drawLine3D(
                        i * spacing - offset, -offset, j * spacing - offset,
                        i * spacing - offset, -offset, (j + 1) * spacing - offset
                    );
                    drawLine3D(
                        i * spacing - offset, -offset, j * spacing - offset,
                        (i + 1) * spacing - offset, -offset, j * spacing - offset
                    );

                    // Vertical lines (walls)
                    drawLine3D(
                        -offset, i * spacing - offset, j * spacing - offset,
                        -offset, i * spacing - offset, (j + 1) * spacing - offset
                    );
                    drawLine3D(
                        offset, i * spacing - offset, j * spacing - offset,
                        offset, i * spacing - offset, (j + 1) * spacing - offset
                    );

                    // Back wall lines
                    drawLine3D(
                        i * spacing - offset, j * spacing - offset, offset,
                        (i + 1) * spacing - offset, j * spacing - offset, offset
                    );
                    drawLine3D(
                        i * spacing - offset, j * spacing - offset, offset,
                        i * spacing - offset, (j + 1) * spacing - offset, offset
                    );
                }
            }

            // Draw grid nodes
            ctx.fillStyle = '#4da6ff';
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    for (let k = 0; k < gridSize; k++) {
                        if (i === 0 || i === gridSize - 1 || j === 0 || j === gridSize - 1 || k === 0 || k === gridSize - 1) {
                            drawNode3D(i * spacing - offset, j * spacing - offset, k * spacing - offset, 3);
                        }
                    }
                }
            }
        }

        function drawLine3D(x1, y1, z1, x2, y2, z2) {
            let p1 = rotate3D(x1, y1, z1, rotationX, rotationY);
            let p2 = rotate3D(x2, y2, z2, rotationX, rotationY);

            if (p1.z < -100 || p2.z < -100) return;

            let proj1 = project(p1.x, p1.y, p1.z);
            let proj2 = project(p2.x, p2.y, p2.z);

            ctx.beginPath();
            ctx.moveTo(proj1.x, proj1.y);
            ctx.lineTo(proj2.x, proj2.y);
            ctx.stroke();
        }

        function drawNode3D(x, y, z, radius) {
            let p = rotate3D(x, y, z, rotationX, rotationY);
            if (p.z < -100) return;

            let proj = project(p.x, p.y, p.z);
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, radius * proj.scale, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw 3D analog clock
        function drawClock() {
            const clockRadius = 120;
            const clockDepth = 30;
            const now = new Date();
            const hours = now.getHours() % 12;
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            const milliseconds = now.getMilliseconds();

            // Smooth second hand movement
            const smoothSeconds = seconds + milliseconds / 1000;

            // Clock face (front)
            drawClockFace(0, 0, 0, clockRadius);

            // Clock face (back for depth)
            drawClockFace(0, 0, clockDepth, clockRadius, true);

            // Clock edge
            drawClockEdge(0, 0, 0, clockRadius, clockDepth);

            // Hour markers
            for (let i = 0; i < 12; i++) {
                const angle = (i * 30 - 90) * Math.PI / 180;
                const outerRadius = clockRadius * 0.85;
                const innerRadius = clockRadius * 0.75;
                const x1 = Math.cos(angle) * innerRadius;
                const y1 = Math.sin(angle) * innerRadius;
                const x2 = Math.cos(angle) * outerRadius;
                const y2 = Math.sin(angle) * outerRadius;
                
                ctx.strokeStyle = '#4da6ff';
                ctx.lineWidth = 3;
                drawLine3D(x1, y1, -5, x2, y2, -5);
            }

            // Hour hand
            const hourAngle = ((hours + minutes / 60) * 30 - 90) * Math.PI / 180;
            const hourLength = clockRadius * 0.5;
            drawClockHand(hourAngle, hourLength, 6, '#66b3ff');

            // Minute hand
            const minuteAngle = ((minutes + smoothSeconds / 60) * 6 - 90) * Math.PI / 180;
            const minuteLength = clockRadius * 0.7;
            drawClockHand(minuteAngle, minuteLength, 4, '#80c0ff');

            // Second hand
            const secondAngle = (smoothSeconds * 6 - 90) * Math.PI / 180;
            const secondLength = clockRadius * 0.8;
            drawClockHand(secondAngle, secondLength, 2, '#ff6b6b');

            // Center dot
            drawNode3D(0, 0, -5, 8);
        }

        function drawClockFace(cx, cy, cz, radius, isBack = false) {
            const segments = 64;
            const points = [];

            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;
                const p = rotate3D(x, y, cz, rotationX, rotationY);
                if (p.z >= -100) {
                    points.push(project(p.x, p.y, p.z));
                }
            }

            if (points.length > 2) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.closePath();
                ctx.fillStyle = isBack ? 'rgba(10, 30, 50, 0.8)' : 'rgba(10, 30, 50, 0.95)';
                ctx.fill();
                ctx.strokeStyle = '#4da6ff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function drawClockEdge(cx, cy, cz, radius, depth) {
            const segments = 32;
            ctx.strokeStyle = '#2d5a7a';
            ctx.lineWidth = 1;

            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;
                drawLine3D(x, y, cz, x, y, cz + depth);
            }
        }

        function drawClockHand(angle, length, width, color) {
            const x = Math.cos(angle) * length;
            const y = Math.sin(angle) * length;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            drawLine3D(0, 0, -5, x, y, -5);
        }

        // Animation loop
        function animate() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, width, height);

            if (autoRotate) {
                rotationY += 0.003;
            }

            drawGrid();
            drawClock();

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
